# 가비지 수집 기초
- GC는 초창기에 상당한 반감을 삿었음
  - 언어 수준에서 의도적으로 GC를 제어하지 못하게 만들었기 때문에
- 하지만 이덕분에 자바의 인지도가 올라가기도 했고 최근 들어서는 메모리 관리는 프로그래머가 아닌 컴파일러,런타임 영역이랑 보는 시각이 많음
- GarbageCollector의 구현체는 이 두가지 원칙을 준수해야함 (여기서는 두번째 원칙이 훨씬 중요하다)
  - 알고리즘은 반드시 모든 가비지를 수집해야 한다.
  - 살아 있는 객체로는 절대로 수집해서는 안된다.
## Mark and Sweep
- 자바의 가장 기초적인 가비지 수집 알고리즘
- Mark and Sweep 알고리즘 순서
  - 할당 리스트를 순회하면서 마크 비트를 지운다.
  - GC 루트로부터 살아 있는 객체를 찾는다.
  - 이렇게 찾은 객체마다 마크 비트를 세팅한다.
  - 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다.
    - 힙에서 메모리를 회수해 프리리스트에 되돌린다.
    - 할당 리스트에서 객체를 삭제한다.
  - 이 알고리즘은 dfs로 실행된다.
### GC 용어
- STW (Stop The World)
  - GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
  - GC가 실행되는 동안에는 애플리케이션 스레드가 실행되지 않는다.
  - 모든 코어를 이용해 빠르게 GC를 실행하기 위함
- 동시
  - GC스레드는 애플리케이션 스레드와 동시 실행될 수 있다.
  - 하지만 아주어렵고 비싼 작업이면 100% 동시실행을 보장하는 알고리즘은 없고 비슷한 알고리즘은 있다.
  - CMS (Concurrent Mark and Sweep)는 동시 알고리즘의 대표적인 예지만 이 알고리즘도 100% 동시가 아니라 조금의 STW가 존재함
- 정확
  - GC 스키마는 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있다.
  - 대략 적으로 int와 포인터의 차이점을 언제나 분간할 수있는 속성을 지닌 스키마가 정확한 것
- 보수
  - 보스적인 스키마는 힙 상태에 관한 충분한 타입 정보를 지니고 있지 않다.
  - 따라서 리소스를 낭비하는 일이 잦고 근복적으로 타입 체계를 무시한다.
- 이동
  - 이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있음
  - 객체 주소가 고정된 것이 아님 (가상,TLSB,영역구분)
- 압착
  - 할당된 메모리는 GC 사이클 마지막에 연속된 영역인 배열이며 포인터가 있음
  - servivor 영역에서 1,2를 계속 왓다갓다(압착) 하며 비우는것 같음
- 방출
  - 수정 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 다른 메모리 영역으로 방출하함